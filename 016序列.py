# 序列
# 列表，元组和字符串有很多相同点统称为序列
# 都可以通过索引值得到每一个元素
# 默认索引值都是从0开始
# 都可以通过分片的方法的到一个范围内的元素的集合
# 很多的共同操作符

# list() 把一个可迭代对象转换成列表
# list()没有参数默认生成一个空的列表
# list（iterable）iterable是指可迭代的
# 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。
# 每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。

# >>> i='1234567897978978465465'
# >>> x=list(i)
# >>> x
# ['1', '2', '3', '4', '5', '6', '7', '8', '9', '7', '9', '7', '8', '9', '7', '8', '4', '6', '5', '4', '6', '5']
# 把字符串转换成列表

# >>> i=(1,2,3,4,5,6,7,8,9)
# >>> x=list(i)
# >>> x
# [1, 2, 3, 4, 5, 6, 7, 8, 9]
# 把元组转换成列表

# tuple() 把一个可迭代对象转换成元组 和list()方式一样
# str() 把参数对象转换成字符串
# len(a)返回长度
# max(1，2，3) 根据ASCII返回参数的最大值 也可以是一个列表x 不同类型不能比较
# min(1,2,3)返回序列或参数集合中的最小值 与max 相反
# sum(iterable[,start=0]) 返回可迭代序列iterable和可选参数start的总和 sum(i,5) 
# 非字符类型（字符串）不可以相加
# sorted() 排序从小到大 sorted(i)
# list(reversed(i))  逆向翻转 
# 如果直接reversed(i)会返回一个迭代器的对象所以我们要用list()将迭代器对象转换成列表

# list(enumerate(i)) 将列表的每一个索引和对应的值生成一个元组并生成一个列表
# i=[1, 2, 3, 4, 5, 6, 7, 8, 9]
# >>> list(enumerate(i))
# [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9)]


# list(zip(a,b)) 将两个列表中索引值相同的值打包生成一个元组并生成一个列表
# >>> i
# (1, 2, 3, 4, 5, 6, 7, 8, 9)
# >>> x=(3,5,6,4,7,8,9,6,9)
# >>> x
# (3, 5, 6, 4, 7, 8, 9, 6, 9)
# >>> list(zip(i,x))
# [(1, 3), (2, 5), (3, 6), (4, 4), (5, 7), (6, 8), (7, 9), (8, 6), (9, 9)]
# >>> 


# name=input('请输入待查找的用户名')
# score=[['迷途',85],['黑夜',80],['小布丁',65],['福禄娃娃',95],['怡静',90]]
# for each in score:
# 	if name==each[0]:
# 		print(name+'的得分是：',each[1])
# 		break
# if name !=each[0]:
# 	print('你要查找的数据不在')


#  min() 这个BIF的实现过程：
# def min(x):
#     least = x[0]
#     for each in x:
#         if each < least:
#             least = each
#     return least
# print(min('123456789'))


# 视频中我们说 sum() 这个BIF有个缺陷，就是如果参数里有字符串类型的话就会报错，
# 请写出一个新的实现过程，自动“无视”参数里的字符串并返回正确的计算结果。


# sum=0
# for i in 列表:
# 	while i.isdigit:
# 		sum=i+sum
# 		